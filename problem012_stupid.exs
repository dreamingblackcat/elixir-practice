# Problem 12
# ==========


#    The sequence of triangle numbers is generated by adding the natural
#    numbers. So the 7^th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 =
#    28. The first ten terms would be:

#                     1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

#    Let us list the factors of the first seven triangle numbers:

#       1: 1
#       3: 1,3
#       6: 1,2,3,6
#      10: 1,2,5,10
#      15: 1,3,5,15
#      21: 1,3,7,21
#      28: 1,2,4,7,14,28

#    We can see that 28 is the first triangle number to have over five
#    divisors.

#    What is the value of the first triangle number to have over five hundred
#    divisors?

   
#    Answer: 8091de7d285989bbfa9a2f9f3bdcc7c0
defmodule Folder do
   def fold(list) do
     _fold([],list)       
   end
   def _fold(prev,[]) do
    prev
   end
   def _fold([],nex) do
      _fold([hd(nex)],tl(nex))
   end

   def _fold(prev,nex) do
    [a | t] = nex
    prev = prev ++ [a] ++ (prev |> Enum.map(&(&1 * a))) |> Enum.uniq
     _fold(prev,t)
   end
        
end

defmodule Problem3 do
  
  def prime?(2), do: true

  def prime?(n) when rem(n,2) == 0, do: false

  def prime?(n) , do: divisors(n) == [n]

  def is_divisible_by?(div,denom), do: rem(denom,div) == 0

  def divisors(n) do
    2..n |> Enum.filter(fn i -> is_divisible_by?(i,n) end)
  end

  def prime_divisors(n) do
    divisors(n) |> Enum.filter(&prime?/1)
  end

  def prime_factorize(n) do
    facts = _prime_factorize(n,2,[])
    facts |> Enum.map(&(cond do !prime? &1 -> _prime_factorize(&1,2,[]); true -> &1 end)) |> Enum.sort
    |> List.flatten
  end

  def _prime_factorize(num,base,factors) do
    cond do
      num == base    -> factors ++ [base]
      rem(num,base) == 0 and prime?(base) -> _prime_factorize(div(num,base),2,factors ++[base])
      true   -> _prime_factorize(num,base + 1,factors)

    end
  end


  def laragest_prime_factor(n) do
    prime_divisors(n) |> Enum.max
  end

end


ExUnit.start

defmodule ConFact do


  
  def concurrent_factorize(n) do
    receive do
      {:start, server_pid} ->
        half_n = div(n,2)
        pid1 = spawn_link(__MODULE__, :_concurrent_factorize,[n,div(half_n,4),1,[]])
        pid2 = spawn_link(__MODULE__, :_concurrent_factorize,[n,div(half_n,4)*2,div(half_n,4),[]])
        pid3 = spawn_link(__MODULE__, :_concurrent_factorize,[n,div(half_n,4)*3,div(half_n,4)*2,[]])
        pid4 = spawn_link(__MODULE__, :_concurrent_factorize,[n,half_n,div(half_n,4)*3,[]]) 
        [pid1,pid2,pid3,pid4] |> Enum.each(&(send &1,{:compute,self}))
        data = concurrent_factorize_wait([],0)
        # IO.inspect data
        send server_pid, {:ok,data}
    end
  end

  def concurrent_factorize_wait(result, count) do
    cond do
      count < 4 -> receive do {:ok, factors} ->concurrent_factorize_wait(result ++ factors,count+1)  end
      
      true       -> result
    end
  end

  def _concurrent_factorize(n,partial_n,current,factors) do
     receive do
       {:compute, server_pid} -> send server_pid, {:ok, partial_factorize(n,partial_n,current,factors)};IO.inspect({n,partial_n,current,factors})
       
     end    
  end

  def partial_factorize(n, partial_n, current, factors) do
    cond do
      current <= partial_n -> partial_factorize(n,partial_n,current+1,cond do rem(n,current) == 0 -> factors++[current]; true -> factors; end)
      true                -> factors   
    end
  end

  def factors_of(n) do
    pid = spawn(ConFact,:concurrent_factorize,[n])
    send pid , {:start,self}
    factors = receive do
       {:ok,facts} -> IO.puts("Factors Count: #{facts |> Enum.count}");facts
    end
  end
end

defmodule ConFind do
    import ConFact
    def concurrent_find(prev,n,list,limit) do
       pid = spawn(ConFact,:concurrent_factorize,[prev+n])
       send pid , {:start,self}
       factors = receive do
          {:ok,facts} -> facts
       end
       cond do
        n < limit -> IO.inspect({"SUM: #{prev+n}","TIMES: #{n}","Factors: #{factors |> Enum.count}"}); concurrent_find(prev + n,n+1,list++[{prev+n,n,factors |> Enum.count}],limit)
        true                                     -> {prev+n,n,factors,list,list |> Enum.sort(fn p,n -> {_,_,f1} = p; {_,_,f2} = n; f1 >= f2 end) |> List.first}
       end
    end

    def normal_find(number,n,fact_count) do
      IO.inspect({number,n,fact_count})
      fact_count = Problem12.factorize(number) 
                   |> Enum.map(fn n -> cond do !Problem3.prime?(n) -> Problem3._prime_factorize(n,2,[]); true -> n end end) 
                   |> List.flatten 
                   |> Enum.sort 
                   |> Folder.fold 
                   |> Enum.count
      cond do
        fact_count <= 400 -> normal_find(number+2,n+1,fact_count)
        true              -> {number, n, fact_count}
      end
    end
end

defmodule Problem12 do
  
  import ConFact
  def stream_triangle_sequence do
    Stream.unfold({1,1}, fn l -> {i,v} = l; {l,{i+1,v+(i+1)}} end)
  end


  def concurrent_find(prev,n) do
     pid = spawn(ConFact,:concurrent_factorize,[prev+n])
     send pid , {:start,self}
     factors = receive do
        {:ok,facts} -> facts
     end
     cond do
      factors |> Enum.count <= 500 ->IO.puts "THE COUNT:"; IO.inspect({prev+n,n+1,factors |> Enum.count}); concurrent_find(prev + n,n+1)
      true                                     -> {prev+n,factors}
     end
  end



  def find(prev,n) do
     factors = factorize(prev+n)
     cond do
      factors |> Enum.count <= 500 -> IO.inspect({prev+n,n+1,factors});find(prev + n,n+1)
      true                                     -> {prev+n,factors}
     end
  end

  def factorize(n) do
    _factorize(n,2,div(n,2),[])
  end

  defp _factorize(n,current,limit,factors) do
    cond do
      n <= 1              -> IO.puts("Yeah!");factors   
      current > limit     -> IO.puts("Yeah!");factors
      rem(n,current) == 0 -> _factorize(div(n,current),2,limit,factors++[current]) 
      rem(n,current) != 0 -> _factorize(n,current+1,limit,factors) 
    end
  end

  def take_last_value(list) do
    {_,val} = (list |> List.last)
    val
  end

  def problem12_result do
    # triangle_sequence |> Enum.take_while(fn tuple -> {_,val} = tuple;IO.inspect(tuple);(factorize(val) |> Enum.count) < 500 end) |> take_last_value
    concurrent_find(70015697, 11832) 
  end
  
end


ExUnit.start

defmodule Problem12Test do

   use ExUnit.Case, async: true
   import Problem12

   test "factorizing 10" do
      assert factorize(10) == [1,2,5]
   end

   test "producing triangle sequence of 7" do
      # assert triangle_sequence |> Enum.take(7) |> take_last_value == 28
   end

   # test "Problem11Test" do
   #  result = problem12_result
   # #  assert "8091de7d285989bbfa9a2f9f3bdcc7c0" == :os.cmd('echo -n #{result} | md5sum') |> List.to_string |> String.split(" ") |> List.first
   # # end
   #  IO.puts "result is #{result}"

end
# {597824065, 184706, 7}
# def find(n,count,multiplier) do
#   f = fn n -> sum = 1..n |> Enum.sum; {sum,ConFact.factors_of(sum)} end
#   {sum,new_count} = f.(n*multiplier) |> Enum.count
#   cond do
#     new_count >= 500   -> {n*multiplier,new_count,sum}
#     new_count >= count -> IO.inspect({n*multiplier,new_count});find(n*multiplier,new_count,2) 
#     new_count < count  -> find(n, count , multiplier+1) 
#   end          
# end

#current biggest sequential find = {27561600, 7424, 385} ,, 32004000, 8000 => last term