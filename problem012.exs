# Problem 12
# ==========


#    The sequence of triangle numbers is generated by adding the natural
#    numbers. So the 7^th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 =
#    28. The first ten terms would be:

#                     1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

#    Let us list the factors of the first seven triangle numbers:

#       1: 1
#       3: 1,3
#       6: 1,2,3,6
#      10: 1,2,5,10
#      15: 1,3,5,15
#      21: 1,3,7,21
#      28: 1,2,4,7,14,28

#    We can see that 28 is the first triangle number to have over five
#    divisors.

#    What is the value of the first triangle number to have over five hundred
#    divisors?

   
#    Answer: 8091de7d285989bbfa9a2f9f3bdcc7c0

defmodule ConFact do
  
  def concurrent_factorize(n) do
    receive do
      {:start, server_pid} ->
        half_n = div(n,2)
        pid1 = spawn_link(__MODULE__, :_concurrent_factorize,[n,div(half_n,4),1,[]])
        pid2 = spawn_link(__MODULE__, :_concurrent_factorize,[n,div(half_n,4)*2,div(half_n,4),[]])
        pid3 = spawn_link(__MODULE__, :_concurrent_factorize,[n,div(half_n,4)*3,div(half_n,4)*2,[]])
        pid4 = spawn_link(__MODULE__, :_concurrent_factorize,[n,half_n,div(half_n,4)*3,[]]) 
        [pid1,pid2,pid3,pid4] |> Enum.each(&(send &1,{:compute,self}))
        data = concurrent_factorize_wait([],0)
        IO.inspect data
        send server_pid, {:ok,data}
    end
  end

  def concurrent_factorize_wait(result, count) do
    IO.puts "Count: #{count}"
    cond do
      count < 4 -> receive do {:ok, factors} ->concurrent_factorize_wait(result ++ factors,count+1)  end
      
      true       -> IO.puts("first factors"); result
    end
  end

  def _concurrent_factorize(n,partial_n,current,factors) do
     receive do
       {:compute, server_pid} -> send server_pid, {:ok, partial_factorize(n,partial_n,current,factors)};IO.inspect({n,partial_n,current,factors})
       
     end 
     IO.puts("Dying")
     IO.inspect(self)    
  end

  def partial_factorize(n, partial_n, current, factors) do
    cond do
      current <= partial_n -> partial_factorize(n,partial_n,current+1,cond do rem(n,current) == 0 -> factors++[current]; true -> factors; end)
      true                -> factors   
    end
  end
end

defmodule ConFind do
  
end

defmodule Problem12 do
  
  import ConFact
  def stream_triangle_sequence do
    Stream.unfold({1,1}, fn l -> {i,v} = l; {l,{i+1,v+(i+1)}} end)
  end


  def concurrent_find(prev,n) do
     pid = spawn(ConFact,:concurrent_factorize,[prev+n])
     send pid , {:start,self}
     factors = receive do
        {:ok,facts} -> facts
     end
     cond do
      factors |> Enum.count <= 500 -> IO.inspect({prev+n,n+1,factors}); concurrent_find(prev + n,n+1)
      true                                     -> {prev+n,factors}
     end
  end



  def find(prev,n) do
     factors = factorize(prev+n)
     cond do
      factors |> Enum.count <= 500 -> IO.inspect({prev+n,n+1,factors});find(prev + n,n+1)
      true                                     -> {prev+n,factors}
     end
  end

  def factorize(n) do
    _factorize(n,1,[])
  end

  defp _factorize(n,current,factors) do
    cond do
      current <= div(n,2) -> _factorize(n,current+1,cond do rem(n,current) == 0 -> factors++[current]; true -> factors; end)
      true                -> factors   
    end
  end

  def take_last_value(list) do
    {_,val} = (list |> List.last)
    val
  end

  def problem12_result do
    # triangle_sequence |> Enum.take_while(fn tuple -> {_,val} = tuple;IO.inspect(tuple);(factorize(val) |> Enum.count) < 500 end) |> take_last_value
    concurrent_find(28,8)
  end
  
end


ExUnit.start

defmodule Problem12Test do

   use ExUnit.Case, async: true
   import Problem12

   test "factorizing 10" do
      assert factorize(10) == [1,2,5]
   end

   test "producing triangle sequence of 7" do
      # assert triangle_sequence |> Enum.take(7) |> take_last_value == 28
   end

   # test "Problem11Test" do
    # result = problem12_result
   #  assert "8091de7d285989bbfa9a2f9f3bdcc7c0" == :os.cmd('echo -n #{result} | md5sum') |> List.to_string |> String.split(" ") |> List.first
   # end
    # IO.puts "result is #{result}"

end